<script>
  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ğŸ—ºï¸ MapTab.vue - D3.js å°ç£åœ°åœ–çµ„ä»¶
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * @fileoverview
   * é€™æ˜¯ä¸€å€‹åŸºæ–¼ D3.js çš„å°ç£åœ°åœ–è¦–è¦ºåŒ–çµ„ä»¶ï¼ŒåŒæ™‚é¡¯ç¤ºç¸£å¸‚ç•Œç·šå’Œç™»é©ç†±ç¶²æ ¼æ•¸æ“šã€‚
   * æœ¬çµ„ä»¶è² è²¬è¼‰å…¥ã€è™•ç†å’Œæ¸²æŸ“å°ç£ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šå’Œç™»é©ç†±ç—…ä¾‹ç¶²æ ¼æ•¸æ“šã€‚
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ“‹ æ ¸å¿ƒåŠŸèƒ½
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * 1. ç¸£å¸‚é‚Šç•Œæ¸²æŸ“ï¼š
   *    âœ“ è¼‰å…¥ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š1140318.geojson
   *    âœ“ ç¹ªè£½æ‰€æœ‰å°ç£ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š
   *
   * 2. ç™»é©ç†±ç¶²æ ¼æ¸²æŸ“ï¼š
   *    âœ“ è¼‰å…¥ dengue_grid_counts_1km_2023_land_only.geojson
   *    âœ“ æ ¹æ“š level å±¬æ€§ç¹ªè£½5ç´šé¢¨éšªç­‰ç´šç¶²æ ¼
   *    âœ“ åªé¡¯ç¤ºç—…ä¾‹æ•¸ > 0 çš„ç¶²æ ¼
   *    âœ“ ä½¿ç”¨5ç´šè‰²ç¥¨ï¼šæ·±è—(1) â†’ ç¶ (2) â†’ é»ƒæ©™(3) â†’ æ©™(4) â†’ ç´…(5)ï¼ˆæœ€ä¸Šå±¤ï¼‰
   *
   * 3. è¦–è¦ºå…ƒç´ ï¼š
   *    âœ“ ç¸£å¸‚ç•Œç·šï¼šæ·ºç°ç´°é‚Šæ¡†ï¼Œç„¡å¡«å……ï¼ˆåº•å±¤ï¼‰
   *    âœ“ ç™»é©ç†±ç¶²æ ¼ï¼š5ç´šè‰²ç¥¨å¡«å……ï¼Œç„¡é‚Šæ¡†ï¼ˆæœ€ä¸Šå±¤ï¼‰
   *    âœ“ ç™½è‰²åœ°åœ–èƒŒæ™¯
   *
   * 4. äº¤äº’åŠŸèƒ½ï¼š
   *    âœ“ æ»¾è¼ªç¸®æ”¾æ§åˆ¶
   *    âœ“ æ‹–å‹•å¹³ç§»å°èˆª
   *    âœ“ æ»‘é¼ æ‡¸åœé¡¯ç¤ºç¶²æ ¼å±¬æ€§è³‡è¨Š
   *    âœ“ ç¶²æ ¼é«˜äº®æ•ˆæœ
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ¨ é…è‰²ä¸»é¡Œ
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ç™½è‰²      #ffffff  â†’ åœ°åœ–èƒŒæ™¯
   * æ·ºç°è‰²    #cccccc  â†’ ç¸£å¸‚é‚Šæ¡†
   * ç„¡å¡«å……    none     â†’ ç¸£å¸‚å€åŸŸ
   * 5ç´šè‰²ç¥¨            â†’ ç™»é©ç†±é¢¨éšªç­‰ç´šï¼ˆæœ€ä¸Šå±¤ï¼‰
   *   Level 1  #1a237e â†’ æ·±è—è‰²
   *   Level 2  #4caf50 â†’ ç¶ è‰²
   *   Level 3  #fbc02d â†’ é»ƒæ©™è‰²
   *   Level 4  #ff6f00 â†’ æ©™è‰²
   *   Level 5  #d32f2f â†’ ç´…è‰²
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ› ï¸ æŠ€è¡“æ£§
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * @requires vue                 - Vue 3.2+ (Composition API)
   * @requires d3                  - D3.js 7.8+ (åœ°åœ–ç¹ªè£½åº«)
   * @requires @/stores/dataStore  - Pinia ç‹€æ…‹ç®¡ç†
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ“ æ•¸æ“šä¾†æº
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šï¼šç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š1140318.geojson
   * ç™»é©ç†±ç¶²æ ¼æ•¸æ“šï¼šdengue_grid_counts_1km_2023_land_only.geojson
   * è·¯å¾‘ï¼špublic/data/geojson/
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ”§ ä½¿ç”¨æ–¹å¼
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * <MapTab @map-ready="handleMapReady" />
   *
   * @event map-ready - åœ°åœ–åˆå§‹åŒ–å®Œæˆæ™‚è§¸ç™¼ï¼Œè¿”å›åœ°åœ–å¯¦ä¾‹
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ“ ç¶­è­·è€…
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * @author Kevin Cheng
   * @version 4.0.0
   * @since 2024
   * @license MIT
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¦ ä¾è³´å°å…¥ (Dependencies Import)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Vue 3 æ ¸å¿ƒåŠŸèƒ½
  import { ref, onMounted, onUnmounted, nextTick } from 'vue';

  // D3.js åœ°åœ–åº«
  import * as d3 from 'd3';

  // Pinia ç‹€æ…‹ç®¡ç†
  import { useDataStore } from '@/stores/dataStore';

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¯ çµ„ä»¶å®šç¾© (Component Definition)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  export default {
    name: 'MapTab',

    // çµ„ä»¶è§¸ç™¼çš„äº‹ä»¶
    emits: [
      'map-ready', // åœ°åœ–åˆå§‹åŒ–å®Œæˆæ™‚è§¸ç™¼ï¼Œå‚³éåœ°åœ–å¯¦ä¾‹
    ],

    /**
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * ğŸ¬ çµ„ä»¶è¨­ç½®å‡½æ•¸ (Component Setup Function)
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * ä½¿ç”¨ Vue 3 Composition API è¨­ç½®çµ„ä»¶é‚è¼¯
     *
     * @param {Object} _ - Propsï¼ˆæœ¬çµ„ä»¶ä¸ä½¿ç”¨ï¼‰
     * @param {Object} context - è¨­ç½®ä¸Šä¸‹æ–‡
     * @param {Function} context.emit - äº‹ä»¶è§¸ç™¼å‡½æ•¸
     * @returns {Object} è¿”å›æ¨¡æ¿å¯ç”¨çš„éŸ¿æ‡‰å¼æ•¸æ“šå’Œæ–¹æ³•
     */
    setup(_, { emit }) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ“¦ ç‹€æ…‹ç®¡ç†èˆ‡ä¾è³´ (State Management & Dependencies)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Pinia æ•¸æ“šå­˜å„²ï¼ˆä¿ç•™ä¾›æœªä¾†æ“´å±•ä½¿ç”¨ï¼‰
      // eslint-disable-next-line no-unused-vars
      const dataStore = useDataStore();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ—ºï¸ åœ°åœ–ç›¸é—œè®Šæ•¸ (Map-Related Variables)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      /**
       * åœ°åœ– DOM å®¹å™¨å¼•ç”¨
       * @type {Ref<HTMLElement|null>}
       */
      const mapContainer = ref(null);

      /**
       * D3.js SVG å…ƒç´ 
       * @type {d3.Selection|null}
       */
      let svg = null;

      /**
       * D3.js æŠ•å½±å‡½æ•¸
       * @type {d3.GeoProjection|null}
       */
      let projection = null;

      /**
       * D3.js è·¯å¾‘ç”Ÿæˆå™¨
       * @type {d3.GeoPath|null}
       */
      let path = null;

      /**
       * D3.js ç¸®æ”¾è¡Œç‚º
       * @type {d3.ZoomBehavior|null}
       */
      let zoom = null;

      /**
       * SVG ä¸»å®¹å™¨çµ„
       * @type {d3.Selection|null}
       */
      let g = null;

      /**
       * å·¥å…·æç¤ºå…ƒç´ 
       * @type {HTMLElement|null}
       */
      let tooltip = null;

      /**
       * Grid ç‰ˆé¢é…ç½®ï¼ˆgrid æ¨¡å¼å°ˆç”¨ï¼‰
       * @type {{
       *   minX: number,
       *   maxX: number,
       *   minY: number,
       *   maxY: number,
       *   cellSize: number,
       *   offsetX: number,
       *   offsetY: number
       * } | null}
       */
      let gridLayoutConfig = null;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ›ï¸ æ§åˆ¶ç‹€æ…‹ (Control States)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      /**
       * åœ°åœ–å°±ç·’ç‹€æ…‹æ¨™è¨˜
       * true = åœ°åœ–å·²åˆå§‹åŒ–å®Œæˆï¼Œfalse = å°šæœªåˆå§‹åŒ–
       * @type {Ref<boolean>}
       */
      const isMapReady = ref(false);

      /**
       * åœ°åœ–å®¹å™¨å”¯ä¸€ ID
       * ä½¿ç”¨éš¨æ©Ÿå­—ç¬¦ä¸²ç¢ºä¿å¤šå¯¦ä¾‹æ™‚ä¸æœƒè¡çª
       * @type {Ref<string>}
       */
      const mapContainerId = ref(`leaflet-map-${Math.random().toString(36).substr(2, 9)}`);

      /**
       * é¡¯ç¤ºæ¨¡å¼
       * 'map' = ä½¿ç”¨åœ°åœ–æŠ•å½±é¡¯ç¤ºï¼ˆç›®å‰çµæœï¼‰
       * 'grid' = ç›´æ¥ä½¿ç”¨ grid_x, grid_y ç¹ªè£½ç¶²æ ¼
       * @type {Ref<string>}
       */
      const displayMode = ref('map');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ“Š GeoJSON æ•¸æ“šå„²å­˜ (GeoJSON Data Storage)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      /**
       * å€ç•Œ GeoJSON æ•¸æ“šï¼ˆè‡ºåŒ—å¸‚ï¼‰
       * ä¾†æºï¼šè‡ºåŒ—å¸‚å€ç•Œåœ–_20220915.geojson
       * @type {Ref<Object|null>}
       */
      const countyData = ref(null);

      /**
       * ç¶²æ ¼ GeoJSON æ•¸æ“šï¼ˆè‡ºåŒ—å¸‚ 500m æ–¹æ ¼ï¼‰
       * ä¾†æºï¼šgrid_with_weighted_angle_stats_500m.geojson
       * @type {Ref<Object|null>}
       */
      const hexData = ref(null);

      /**
       * ç™»é©ç†±ç¶²æ ¼ GeoJSON æ•¸æ“šï¼ˆä¿ç•™ä»¥å…¼å®¹ï¼‰
       * ä¾†æºï¼šdengue_grid_counts_1km_2023_land_only.geojson
       * @type {Ref<Object|null>}
       */
      const dengueData = ref(null);

      /**
       * ğŸ“¥ è¼‰å…¥ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON æ•¸æ“š
       */
      const loadCountyData = async () => {
        try {
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON æ•¸æ“š...');

          // è¼‰å…¥è‡ºåŒ—å¸‚å€ç•Œ GeoJSON æª”æ¡ˆ
          const countyResponse = await fetch(
            `${process.env.BASE_URL}data/geojson/è‡ºåŒ—å¸‚å€ç•Œåœ–_20220915.geojson`
          );

          // æª¢æŸ¥éŸ¿æ‡‰
          if (!countyResponse.ok) {
            throw new Error(`ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šæ•¸æ“šè¼‰å…¥å¤±æ•—: HTTP ${countyResponse.status}`);
          }

          // è§£æ JSON
          countyData.value = await countyResponse.json();

          console.log('[MapTab] è‡ºåŒ—å¸‚å€ç•Œæ•¸æ“šè¼‰å…¥æˆåŠŸ');
          console.log('  - å€æ•¸é‡:', countyData.value.features?.length || 0);

          return true;
        } catch (error) {
          console.error('[MapTab] ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šæ•¸æ“šè¼‰å…¥å¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ› ï¸ å‰µå»ºå·¥å…·æç¤ºå…ƒç´ 
       */
      const createTooltip = () => {
        if (!mapContainer.value) return;

        // ç§»é™¤å·²å­˜åœ¨çš„å·¥å…·æç¤º
        const existingTooltip = mapContainer.value.querySelector('.map-tooltip');
        if (existingTooltip) {
          existingTooltip.remove();
        }

        // å‰µå»ºæ–°çš„å·¥å…·æç¤ºå…ƒç´ 
        tooltip = document.createElement('div');
        tooltip.className = 'map-tooltip';
        tooltip.style.position = 'absolute';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.opacity = '0';
        tooltip.style.padding = '4px 8px';

        mapContainer.value.appendChild(tooltip);
        console.log('[MapTab] å·¥å…·æç¤ºå…ƒç´ å‰µå»ºæˆåŠŸ');
      };

      /**
       * ğŸ“¥ è¼‰å…¥ç¶²æ ¼ GeoJSON æ•¸æ“š
       */
      const loadHexData = async () => {
        try {
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ 500m æ–¹æ ¼ GeoJSON æ•¸æ“š...');

          // è¼‰å…¥è‡ºåŒ—å¸‚ 500m æ–¹æ ¼ GeoJSON æª”æ¡ˆ
          const hexResponse = await fetch(
            `${process.env.BASE_URL}data/geojson/grid_with_weighted_angle_stats_500m.geojson`
          );

          // æª¢æŸ¥éŸ¿æ‡‰
          if (!hexResponse.ok) {
            throw new Error(`æ–¹æ ¼æ•¸æ“šè¼‰å…¥å¤±æ•—: HTTP ${hexResponse.status}`);
          }

          // è§£æ JSON
          hexData.value = await hexResponse.json();

          console.log('[MapTab] 500m æ–¹æ ¼æ•¸æ“šè¼‰å…¥æˆåŠŸ');
          console.log('  - ç¶²æ ¼æ•¸é‡:', hexData.value.features?.length || 0);

          return true;
        } catch (error) {
          console.error('[MapTab] 500m æ–¹æ ¼æ•¸æ“šè¼‰å…¥å¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ“¥ è¼‰å…¥ç™»é©ç†±ç¶²æ ¼ GeoJSON æ•¸æ“š
       */
      // eslint-disable-next-line no-unused-vars
      const loadDengueData = async () => {
        try {
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ç™»é©ç†±ç¶²æ ¼ GeoJSON æ•¸æ“š...');

          // è¼‰å…¥ç™»é©ç†±ç¶²æ ¼ GeoJSON æª”æ¡ˆ
          const dengueResponse = await fetch(
            `${process.env.BASE_URL}data/geojson/dengue_grid_counts_1km_2023_land_only.geojson`
          );

          // æª¢æŸ¥éŸ¿æ‡‰
          if (!dengueResponse.ok) {
            throw new Error(`ç™»é©ç†±ç¶²æ ¼æ•¸æ“šè¼‰å…¥å¤±æ•—: HTTP ${dengueResponse.status}`);
          }

          // è§£æ JSON
          dengueData.value = await dengueResponse.json();

          console.log('[MapTab] ç™»é©ç†±ç¶²æ ¼æ•¸æ“šè¼‰å…¥æˆåŠŸ');
          console.log('  - ç¶²æ ¼æ•¸é‡:', dengueData.value.features?.length || 0);

          return true;
        } catch (error) {
          console.error('[MapTab] ç™»é©ç†±ç¶²æ ¼æ•¸æ“šè¼‰å…¥å¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ“Š Jenks Natural Breaks åˆ†é¡å‡½æ•¸
       * @param {Array} data - æ•¸æ“šé™£åˆ—
       * @param {number} nClasses - åˆ†é¡æ•¸é‡
       * @returns {Array} åˆ†é¡é–¾å€¼é™£åˆ—
       */
      // eslint-disable-next-line no-unused-vars
      const jenksNaturalBreaks = (data, nClasses) => {
        if (!data || data.length === 0) return [];

        const sortedData = [...data].sort((a, b) => a - b);
        const dataLength = sortedData.length;

        // å¦‚æœè¦åˆ†é¡æ•¸å¤§æ–¼æ•¸æ“šé»æ•¸ï¼Œè¿”å›æ•¸æ“šé»æ•¸
        if (nClasses > dataLength) {
          nClasses = dataLength;
        }

        // åˆå§‹åŒ–çŸ©é™£
        const matrix = [];
        for (let i = 0; i < dataLength + 1; i++) {
          matrix[i] = [];
          for (let j = 0; j < nClasses + 1; j++) {
            matrix[i][j] = 0;
          }
        }

        // è¨ˆç®—ä¸‹ä¸‰è§’çŸ©é™£ï¼ˆæ–¹å·®ï¼‰
        const lowerClassLimit = [];
        for (let i = 0; i < dataLength + 1; i++) {
          lowerClassLimit[i] = [];
          for (let j = 0; j < nClasses + 1; j++) {
            lowerClassLimit[i][j] = 0;
          }
        }

        let variance = 0;

        // è¨ˆç®—æ–¹å·®
        for (let i = 1; i < nClasses + 1; i++) {
          matrix[0][i] = 1;
          lowerClassLimit[0][i] = 0;
          for (let j = 1; j < dataLength + 1; j++) {
            matrix[j][i] = Infinity;
          }
        }

        for (let l = 0; l < dataLength; l++) {
          let sum = 0;
          let sumSquares = 0;
          let w = 0;

          for (let m = 0; m < l + 1; m++) {
            const lowerClassLimitIndex = l - m + 1;
            const val = sortedData[lowerClassLimitIndex - 1];
            w++;
            sum += val;
            sumSquares += val * val;
            variance = sumSquares - (sum * sum) / w;
            const i4 = lowerClassLimitIndex - 1;

            if (i4 !== 0) {
              for (let j = 2; j < nClasses + 1; j++) {
                if (matrix[l][j] >= variance + matrix[i4][j - 1]) {
                  lowerClassLimit[l][j] = lowerClassLimitIndex;
                  matrix[l][j] = variance + matrix[i4][j - 1];
                }
              }
            }
          }

          lowerClassLimit[l][1] = 1;
          matrix[l][1] = variance;
        }

        // æå–åˆ†é¡é–¾å€¼
        const classMarkers = [];
        let k = dataLength;
        for (let j = nClasses; j > 0; j--) {
          const id = lowerClassLimit[k][j] - 2;
          classMarkers[j - 1] = sortedData[id + 1];
          k = lowerClassLimit[k][j] - 1;
        }

        return classMarkers;
      };

      /**
       * ğŸ—ºï¸ ç¹ªè£½ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š
       */
      const drawCounties = () => {
        if (!g || !countyData.value) {
          console.error(
            '[MapTab] ç„¡æ³•ç¹ªè£½ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š: g=',
            !!g,
            'countyData=',
            !!countyData.value
          );
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON');

          // ç¹ªè£½æ‰€æœ‰è¡Œæ”¿å€ï¼ˆè‡ºåŒ—å¸‚ï¼‰
          g.selectAll('.county')
            .data(countyData.value.features)
            .enter()
            .append('path')
            .attr('d', path)
            .attr('class', 'county')
            .attr('fill', 'none')
            .attr('stroke', '#222')
            .attr('stroke-width', 1.2)
            .attr('stroke-opacity', 0.9)
            .attr('vector-effect', 'non-scaling-stroke');

          console.log('[MapTab] ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON ç¹ªè£½å®Œæˆ');
        } catch (error) {
          console.error('[MapTab] ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON ç¹ªè£½å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ—ï¸ å‰µå»ºç¶²æ ¼ç•«å¸ƒï¼ˆä¸ä¾è³´åœ°åœ–æŠ•å½±ï¼‰
       * ç”¨æ–¼ grid æ¨¡å¼ï¼Œç›´æ¥ä½¿ç”¨ grid_x, grid_y ç¹ªè£½
       */
      // eslint-disable-next-line no-unused-vars
      const createGridCanvas = () => {
        if (!mapContainer.value) return false;

        const rect = mapContainer.value.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          console.warn('[MapTab] å®¹å™¨å°ºå¯¸ç‚ºé›¶ï¼Œå»¶é²åˆå§‹åŒ–');
          return false;
        }

        try {
          // æ¸…é™¤èˆŠçš„ SVG
          if (svg) {
            svg.remove();
          }

          projection = null;
          path = null;
          gridLayoutConfig = null;

          const width = rect.width;
          const height = rect.height;

          // å‰µå»º SVG å…ƒç´ ï¼ˆä¸å¸¶åœ°åœ–æŠ•å½±ï¼‰
          svg = d3
            .select(mapContainer.value)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('background', '#ffffff'); // ç™½è‰²èƒŒæ™¯

          // å‰µå»ºå®¹å™¨çµ„ï¼ˆä¸ä½¿ç”¨åœ°åœ–æŠ•å½±ï¼‰
          g = svg.append('g');

          // è¨­ç½®ç¸®æ”¾è¡Œç‚ºï¼ˆç”¨æ–¼ç¶²æ ¼ç¸®æ”¾ï¼‰
          zoom = d3
            .zoom()
            .scaleExtent([0.5, 50]) // å…è¨±ç¸®æ”¾ 0.5x åˆ° 50x
            .on('zoom', (event) => {
              g.attr('transform', event.transform);
            });

          svg.call(zoom);

          // é‡ç½®ç¸®æ”¾ç‹€æ…‹ï¼Œç¢ºä¿åˆ‡æ›æ¨¡å¼æ™‚ä¸æœƒå—åˆ°ä¹‹å‰æ¨¡å¼çš„å½±éŸ¿
          svg.call(zoom.transform, d3.zoomIdentity);

          // å‰µå»ºå·¥å…·æç¤ºå…ƒç´ 
          createTooltip();

          isMapReady.value = true;

          console.log('[MapTab] ç¶²æ ¼ç•«å¸ƒå‰µå»ºæˆåŠŸ');
          return true;
        } catch (error) {
          console.error('[MapTab] ç¶²æ ¼ç•«å¸ƒå‰µå»ºå¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ—ºï¸ ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼ç‰ˆæœ¬ï¼‰
       * ä½¿ç”¨ grid_xã€grid_y æ’åˆ—ï¼Œä¸ä¾è³´ GeoJSON coordinates
       */
      const drawHexGridOnly = () => {
        if (!g || !hexData.value) {
          console.error('[MapTab] ç„¡æ³•ç¹ªè£½æ–¹æ ¼: g=', !!g, 'hexData=', !!hexData.value);
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½æ–¹æ ¼ï¼ˆGrid æ¨¡å¼ï¼Œä½¿ç”¨ grid_x/grid_yï¼‰');

          // å…ˆæ¸…é™¤èˆŠçš„åœ–å±¤ï¼ˆåŒ…æ‹¬ç¸£å¸‚ç•Œç·šï¼‰
          g.selectAll('.hex-grid').remove();
          g.selectAll('.county').remove();

          const gridsWithXY = (hexData.value.features || []).filter((feature) => {
            const gx = feature?.properties?.grid_x;
            const gy = feature?.properties?.grid_y;
            return Number.isFinite(gx) && Number.isFinite(gy);
          });

          if (gridsWithXY.length === 0) {
            console.warn('[MapTab] ç„¡æ³•æ‰¾åˆ° grid_x æˆ– grid_y å±¬æ€§');
            gridLayoutConfig = null;
            return;
          }

          const gridXValues = gridsWithXY.map((d) => d.properties.grid_x);
          const gridYValues = gridsWithXY.map((d) => d.properties.grid_y);

          const minX = d3.min(gridXValues);
          const maxX = d3.max(gridXValues);
          const minY = d3.min(gridYValues);
          const maxY = d3.max(gridYValues);

          const svgWidth =
            (svg ? +svg.attr('width') : null) || mapContainer.value.getBoundingClientRect().width;
          const svgHeight =
            (svg ? +svg.attr('height') : null) || mapContainer.value.getBoundingClientRect().height;

          if (
            !Number.isFinite(svgWidth) ||
            !Number.isFinite(svgHeight) ||
            svgWidth === 0 ||
            svgHeight === 0
          ) {
            console.warn('[MapTab] SVG å°ºå¯¸ç„¡æ•ˆï¼Œç„¡æ³•ç¹ªè£½ grid');
            gridLayoutConfig = null;
            return;
          }

          const padding = 40;
          const availableWidth = Math.max(svgWidth - padding * 2, 0);
          const availableHeight = Math.max(svgHeight - padding * 2, 0);

          const rangeX = Math.max(maxX - minX + 1, 1);
          const rangeY = Math.max(maxY - minY + 1, 1);

          const cellSize = Math.min(availableWidth / rangeX, availableHeight / rangeY);

          if (!Number.isFinite(cellSize) || cellSize <= 0) {
            console.warn('[MapTab] è¨ˆç®—å‡ºçš„ cellSize ç„¡æ•ˆ:', cellSize);
            gridLayoutConfig = null;
            return;
          }

          const actualWidth = cellSize * rangeX;
          const actualHeight = cellSize * rangeY;

          const offsetX = (svgWidth - actualWidth) / 2;
          const offsetY = (svgHeight - actualHeight) / 2;

          gridLayoutConfig = {
            minX,
            maxX,
            minY,
            maxY,
            cellSize,
            offsetX,
            offsetY,
          };

          const strokeWidth = Math.max(cellSize * 0.06, 0.4);

          const hexCells = g
            .selectAll('.hex-grid')
            .data(gridsWithXY, (d) => `${d.properties.grid_x}-${d.properties.grid_y}`)
            .join('rect')
            .attr('class', 'hex-grid')
            .attr('x', (d) => offsetX + (d.properties.grid_x - minX) * cellSize)
            .attr('y', (d) => offsetY + (maxY - d.properties.grid_y) * cellSize)
            .attr('width', cellSize)
            .attr('height', cellSize)
            .attr('fill', 'none')
            .attr('stroke', '#999')
            .attr('stroke-width', strokeWidth)
            .attr('stroke-opacity', 0.7)
            .attr('shape-rendering', 'crispEdges')
            .attr('vector-effect', 'non-scaling-stroke')
            .style('cursor', 'pointer');

          hexCells
            .on('mouseover', function (event, d) {
              d3.select(this)
                .attr('stroke-width', strokeWidth * 1.3)
                .attr('stroke-opacity', 1);
              if (tooltip) {
                const properties = d.properties || {};
                let tooltipHTML = '';
                Object.keys(properties).forEach((key) => {
                  const value = properties[key];
                  tooltipHTML += `<div><strong>${key}:</strong> ${value !== null && value !== undefined ? value : 'N/A'}</div>`;
                });
                tooltip.innerHTML = tooltipHTML;
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
                tooltip.style.opacity = 1;
              }
            })
            .on('mousemove', function (event) {
              if (tooltip) {
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
              }
            })
            .on('mouseout', function () {
              d3.select(this).attr('stroke-width', strokeWidth).attr('stroke-opacity', 0.7);
              if (tooltip) {
                tooltip.style.opacity = 0;
              }
            });

          console.log('[MapTab] æ–¹æ ¼ï¼ˆGrid æ¨¡å¼ï¼‰ç¹ªè£½å®Œæˆ', {
            cells: gridsWithXY.length,
            cellSize,
            offsetX,
            offsetY,
          });

          // åœ¨æ¯å€‹æ–¹æ ¼ä¸­å¿ƒç¹ªè£½å€Ÿè»Š/é‚„è»Šè§’åº¦ç®­é ­
          drawAngleArrows();
        } catch (error) {
          console.error('[MapTab] æ–¹æ ¼ç¹ªè£½å¤±æ•—:', error);
          gridLayoutConfig = null;
        }
      };

      /**
       * ğŸ—ºï¸ ç¹ªè£½ç¶²æ ¼ï¼ˆä½¿ç”¨ grid_x, grid_yï¼Œä¸ä½¿ç”¨åº§æ¨™ï¼‰
       * å®Œå…¨ç¨ç«‹çš„å¯¦ç¾ï¼Œä¸ä¾è³´åœ°åœ–æŠ•å½±
       */
      // eslint-disable-next-line no-unused-vars
      const drawGridOnly = () => {
        if (!g || !dengueData.value) {
          console.error('[MapTab] ç„¡æ³•ç¹ªè£½ç¶²æ ¼: g=', !!g, 'dengueData=', !!dengueData.value);
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½ç¶²æ ¼ï¼ˆä½¿ç”¨ grid_x, grid_yï¼‰');

          // æ¸…é™¤èˆŠçš„ç¶²æ ¼
          g.selectAll('.dengue-grid').remove();

          // é¡è‰²æ˜ å°„
          const levelColors = {
            0: '#e0e0e0', // æ·¡ç°è‰²ï¼ˆlevel 0ï¼‰
            1: '#1a237e', // æ·±è—è‰²ï¼ˆæ·±è‰²ï¼‰
            2: '#4caf50', // ç¶ è‰²ï¼ˆè¼ƒäº®ï¼‰
            3: '#fbc02d', // é»ƒæ©™è‰²ï¼ˆé‡‘è‰²ï¼‰
            4: '#ff6f00', // æ©™è‰²ï¼ˆæ˜äº®ï¼‰
            5: '#d32f2f', // ç´…è‰²ï¼ˆæ·±è‰²ï¼‰
          };

          // é¡è‰²æ˜ å°„å‡½æ•¸
          const getColorByLevel = (level) => {
            if (level === 0 || level === null || level === undefined) {
              return levelColors[0];
            }
            return levelColors[level] || levelColors[1];
          };

          // é€æ˜åº¦æ˜ å°„å‡½æ•¸
          const getOpacityByLevel = (level) => {
            const levelNum = level || 0;
            const opacityMap = {
              0: 0.5,
              1: 0.7,
              2: 0.75,
              3: 0.8,
              4: 0.85,
              5: 0.9,
            };
            return opacityMap[levelNum] || opacityMap[0];
          };

          // éæ¿¾æœ‰ grid_x å’Œ grid_y çš„æ•¸æ“š
          const gridsWithXY = dengueData.value.features.filter(
            (d) =>
              d.properties.grid_x !== null &&
              d.properties.grid_x !== undefined &&
              d.properties.grid_y !== null &&
              d.properties.grid_y !== undefined
          );

          if (gridsWithXY.length === 0) {
            console.error('[MapTab] ç„¡æ³•æ‰¾åˆ° grid_x æˆ– grid_y å±¬æ€§');
            return;
          }

          // è¨ˆç®— grid_x å’Œ grid_y çš„ç¯„åœ
          const gridXValues = gridsWithXY.map((d) => d.properties.grid_x);
          const gridYValues = gridsWithXY.map((d) => d.properties.grid_y);

          const minX = d3.min(gridXValues);
          const maxX = d3.max(gridXValues);
          const minY = d3.min(gridYValues);
          const maxY = d3.max(gridYValues);

          console.log('[MapTab] Grid ç¯„åœ:', { minX, maxX, minY, maxY });

          // ç²å– SVG å°ºå¯¸ï¼ˆåœ¨ svg å°šæœªå»ºç«‹æ™‚å›é€€åˆ°å®¹å™¨å°ºå¯¸ï¼‰
          const svgWidth =
            (svg ? +svg.attr('width') : null) || mapContainer.value.getBoundingClientRect().width;
          const svgHeight =
            (svg ? +svg.attr('height') : null) || mapContainer.value.getBoundingClientRect().height;

          // å‰µå»ºæ¯”ä¾‹å°ºï¼ˆå¸¶æœ‰ä¸€äº›é‚Šè·ï¼‰
          const padding = 50;
          const availableWidth = svgWidth - 2 * padding;
          const availableHeight = svgHeight - 2 * padding;

          // è¨ˆç®— grid ç¯„åœï¼ˆåŒ…æ‹¬é‚Šç•Œï¼‰
          const rangeX = maxX - minX + 1;
          const rangeY = maxY - minY + 1;

          // è¨ˆç®—ç†è«–å–®å…ƒå¤§å°ï¼ˆæ ¹æ“šå¯ç”¨ç©ºé–“å’Œç¯„åœï¼‰
          const cellWidthFromX = availableWidth / rangeX;
          const cellHeightFromY = availableHeight / rangeY;

          // ä½¿ç”¨è¼ƒå°çš„å€¼ä½œç‚ºçµ±ä¸€çš„å–®å…ƒå¤§å°ï¼Œç¢ºä¿æ‰€æœ‰ç¶²æ ¼éƒ½æ˜¯æ­£æ–¹å½¢ä¸”èƒ½å®Œæ•´é¡¯ç¤º
          const cellSize = Math.min(cellWidthFromX, cellHeightFromY);

          // æ ¹æ“šå¯¦éš›å–®å…ƒå¤§å°è¨ˆç®—å¯¦éš›ä½¿ç”¨çš„ç©ºé–“
          const actualWidth = cellSize * rangeX;
          const actualHeight = cellSize * rangeY;

          // è¨ˆç®—å±…ä¸­åç§»é‡
          const offsetX = (svgWidth - actualWidth) / 2;
          const offsetY = (svgHeight - actualHeight) / 2;

          // å‰µå»ºæ¯”ä¾‹å°ºï¼ˆä½¿ç”¨çµ±ä¸€çš„å–®å…ƒå¤§å°ï¼Œä¸¦å±…ä¸­é¡¯ç¤ºï¼‰
          const scaleX = d3
            .scaleLinear()
            .domain([minX, maxX + 1])
            .range([offsetX, offsetX + actualWidth]);
          // Y è»¸ï¼šgrid_y æœ€å°å€¼åœ¨ä¸Šæ–¹ï¼Œæœ€å¤§å€¼åœ¨ä¸‹æ–¹ï¼ˆSVG åæ¨™ç³»ï¼šy=0 åœ¨é ‚éƒ¨ï¼Œå‘ä¸‹éå¢ï¼‰
          const scaleY = d3
            .scaleLinear()
            .domain([minY, maxY + 1])
            .range([offsetY, offsetY + actualHeight]);

          console.log('[MapTab] Grid å–®å…ƒå¤§å°:', {
            cellSize,
            rangeX,
            rangeY,
            cellWidthFromX,
            cellHeightFromY,
          });

          // ç¶²æ ¼å–®å…ƒå¤§å°ï¼ˆçµ±ä¸€ç‚ºæ­£æ–¹å½¢ï¼‰
          const cellWidth = cellSize;
          const cellHeight = cellSize;

          // æŒ‰ level æ’åºï¼šlevel 0 åœ¨åº•å±¤ï¼Œlevel 1-5 åœ¨ä¸Šå±¤
          const sortedGrids = gridsWithXY.sort((a, b) => {
            const levelA = a.properties.level || 0;
            const levelB = b.properties.level || 0;
            return levelA - levelB;
          });

          // ç¹ªè£½ç¶²æ ¼çŸ©å½¢
          g.selectAll('.dengue-grid')
            .data(sortedGrids)
            .enter()
            .append('rect')
            .attr('class', 'dengue-grid')
            .attr('x', (d) => scaleX(d.properties.grid_x))
            .attr('y', (d) => scaleY(d.properties.grid_y))
            .attr('width', cellWidth)
            .attr('height', cellHeight)
            .attr('fill', (d) => getColorByLevel(d.properties.level))
            .attr('fill-opacity', (d) => getOpacityByLevel(d.properties.level))
            .attr('stroke', 'none')
            .style('cursor', 'pointer')
            .on('mouseover', function (event, d) {
              d3.select(this).attr('fill-opacity', 1);
              if (tooltip) {
                const properties = d.properties;
                // é¡¯ç¤ºæ‰€æœ‰ properties æ¬„ä½
                let tooltipHTML = '';
                Object.keys(properties).forEach((key) => {
                  const value = properties[key];
                  tooltipHTML += `<div><strong>${key}:</strong> ${value !== null && value !== undefined ? value : 'N/A'}</div>`;
                });
                tooltip.innerHTML = tooltipHTML;
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
                tooltip.style.opacity = 1;
              }
            })
            .on('mousemove', function (event) {
              if (tooltip) {
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
              }
            })
            .on('mouseout', function (event, d) {
              const level = d.properties.level || 0;
              d3.select(this).attr('fill-opacity', getOpacityByLevel(level));
              if (tooltip) {
                tooltip.style.opacity = 0;
              }
            });

          console.log('[MapTab] ç¶²æ ¼ç¹ªè£½å®Œæˆ');
          console.log('  - ç¶²æ ¼æ•¸é‡:', sortedGrids.length);
        } catch (error) {
          console.error('[MapTab] ç¶²æ ¼ç¹ªè£½å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ›ï¸ åˆ‡æ›é¡¯ç¤ºæ¨¡å¼
       * @param {string} mode - 'map' æˆ– 'grid'
       */
      const toggleDisplayMode = async (mode) => {
        displayMode.value = mode;
        console.log('[MapTab] åˆ‡æ›é¡¯ç¤ºæ¨¡å¼:', mode);

        if (displayMode.value === 'map') {
          gridLayoutConfig = null;
          // åœ°åœ–æ¨¡å¼ï¼šéœ€è¦åœ°åœ–æŠ•å½±ï¼Œè¼‰å…¥ç¸£å¸‚ç•Œç·šå’Œå…­è§’å½¢ç¶²æ ¼
          if (!countyData.value) {
            await loadCountyData();
          }
          if (!hexData.value) {
            await loadHexData();
          }

          // æ¸…é™¤èˆŠçš„ SVGï¼ˆå¦‚æœå¾å…¶ä»–æ¨¡å¼åˆ‡æ›éä¾†ï¼‰
          if (svg && !projection) {
            svg.remove();
            svg = null;
          }

          if (!projection || !path) {
            // å¦‚æœé‚„æ²’æœ‰å‰µå»ºåœ°åœ–ï¼Œå…ˆå‰µå»º
            const rect = mapContainer.value.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              const width = rect.width;
              const height = rect.height;

              // æ¸…é™¤èˆŠçš„ SVG
              if (svg) {
                svg.remove();
              }

              // å‰µå»º SVG å’Œåœ°åœ–æŠ•å½±
              svg = d3
                .select(mapContainer.value)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#ffffff');

              projection = d3.geoMercator();
              if (countyData.value) {
                projection.fitExtent(
                  [
                    [20, 20],
                    [width - 20, height - 20],
                  ],
                  countyData.value
                );
              } else {
                projection
                  .center([121, 25.05])
                  .scale(45000)
                  .translate([width / 2, height / 2]);
              }

              path = d3.geoPath().projection(projection);
              g = svg.append('g');

              zoom = d3
                .zoom()
                .scaleExtent([0.8, 12])
                .on('zoom', (event) => {
                  g.attr('transform', event.transform);
                });

              svg.call(zoom);

              // é‡ç½®ç¸®æ”¾ç‹€æ…‹ï¼Œç¢ºä¿åˆ‡æ›æ¨¡å¼æ™‚ä¸æœƒå—åˆ°ä¹‹å‰æ¨¡å¼çš„å½±éŸ¿
              svg.call(zoom.transform, d3.zoomIdentity);

              createTooltip();
              isMapReady.value = true;
            }
          } else {
            // å¦‚æœå·²ç¶“å‰µå»ºäº†åœ°åœ–ï¼Œé‡ç½®ç¸®æ”¾ç‹€æ…‹
            if (svg && zoom) {
              svg.call(zoom.transform, d3.zoomIdentity);
            }
          }
          // ç¹ªè£½ç¸£å¸‚ç•Œç·šå’Œå…­è§’å½¢ç¶²æ ¼
          drawCounties();
          drawHexGrid();
        } else {
          // æ¸…é™¤ç¸£å¸‚ç•Œç·šæ•¸æ“šï¼ˆä¸éœ€è¦ï¼‰
          countyData.value = null;
          gridLayoutConfig = null;

          // Grid æ¨¡å¼ï¼šè¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“šï¼Œä½¿ç”¨ grid_x/grid_y æ’åˆ—
          if (!hexData.value) {
            await loadHexData();
          }

          if (!createGridCanvas()) {
            console.warn('[MapTab] Grid ç•«å¸ƒå»ºç«‹å¤±æ•—ï¼Œæš«åœç¹ªåœ–');
            return;
          }

          // ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼ï¼Œä½¿ç”¨ grid_x/grid_yï¼‰
          drawHexGridOnly();
        }
      };

      /**
       * ğŸ—ºï¸ ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆä½¿ç”¨å¤§é™¸åœ°å€äººæ°‘æ ¸å‡†å®šå±…æ•¸æ“šï¼‰
       */
      const drawHexGrid = () => {
        if (!g || !hexData.value || !path) {
          console.error(
            '[MapTab] ç„¡æ³•ç¹ªè£½æ–¹æ ¼: g=',
            !!g,
            'hexData=',
            !!hexData.value,
            'path=',
            !!path
          );
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½æ–¹æ ¼ GeoJSON');

          // å…ˆæ¸…é™¤èˆŠçš„åœ–å±¤
          g.selectAll('.hex-grid').remove();
          // Map æ¨¡å¼ï¼šä½¿ç”¨åœ°åœ–æŠ•å½±ç¹ªè£½ï¼ˆä½¿ç”¨ GeoJSON coordinatesï¼‰
          console.log('[MapTab] ä½¿ç”¨ Map æ¨¡å¼ç¹ªè£½ï¼ˆåœ°åœ–æŠ•å½±ï¼‰');
          console.log('[MapTab] path generator:', !!path, 'g:', !!g);

          // ç›´æ¥ç¹ªè£½æ‰€æœ‰ç¶²æ ¼ï¼ˆç„¡åˆ†é¡ã€ç„¡å¡«è‰²ï¼‰
          const hexPaths = g
            .selectAll('.hex-grid')
            .data(hexData.value.features)
            .enter()
            .append('path')
            .attr('d', path)
            .attr('class', 'hex-grid')
            .attr('fill', 'none')
            .attr('stroke', '#999')
            .attr('stroke-width', 0.5)
            .attr('stroke-opacity', 0.7)
            .attr('shape-rendering', 'crispEdges')
            .attr('vector-effect', 'non-scaling-stroke')
            .style('cursor', 'pointer');

          console.log('[DEBUG] ç¹ªè£½äº†å¤šå°‘å€‹ path å…ƒç´ :', hexPaths.size());

          hexPaths
            .on('mouseover', function (event, d) {
              d3.select(this).attr('fill-opacity', 1).attr('stroke-width', 2);
              if (tooltip) {
                const properties = d.properties;
                // é¡¯ç¤ºæ‰€æœ‰ properties æ¬„ä½
                let tooltipHTML = '';
                Object.keys(properties).forEach((key) => {
                  const value = properties[key];
                  tooltipHTML += `<div><strong>${key}:</strong> ${value !== null && value !== undefined ? value : 'N/A'}</div>`;
                });
                tooltip.innerHTML = tooltipHTML;
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
                tooltip.style.opacity = 1;
              }
            })
            .on('mousemove', function (event) {
              if (tooltip) {
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
              }
            })
            .on('mouseout', function () {
              d3.select(this).attr('fill-opacity', 0.8).attr('stroke-width', 0.5);
              if (tooltip) {
                tooltip.style.opacity = 0;
              }
            });

          console.log('[MapTab] æ–¹æ ¼ï¼ˆåœ°åœ–æ¨¡å¼ï¼‰ç¹ªè£½å®Œæˆ');
          console.log('  - SVG ä¸­çš„ path å…ƒç´ æ•¸é‡:', g.selectAll('path').size());
          console.log('  - hex-grid class å…ƒç´ æ•¸é‡:', g.selectAll('.hex-grid').size());

          // åœ¨æ¯å€‹æ–¹æ ¼ä¸­å¿ƒç¹ªè£½å€Ÿè»Š/é‚„è»Šè§’åº¦ç®­é ­
          drawAngleArrows();
        } catch (error) {
          console.error('[MapTab] æ–¹æ ¼ç¹ªè£½å¤±æ•—:', error);
        }
      };

      // ï¼ˆå·²ç§»é™¤ï¼‰åŸæœ¬ç”¨æ–¼é™¤éŒ¯çš„ç´…é»é¡¯ç¤ºå‡½æ•¸ drawGridCentroids

      // å·²ç§»é™¤ï¼šåŸ SVG marker ç®­é ­å°–ç«¯

      /**
       * ğŸ§­ åœ¨æ¯å€‹ç¶²æ ¼çš„ä¸­å¿ƒç•«å‡ºå€Ÿè»Š/é‚„è»Šè§’åº¦çš„ç®­é ­
       * - å€Ÿè»Šï¼šç¶ è‰²ï¼Œä½¿ç”¨ marker 'arrow-borrow'
       * - é‚„è»Šï¼šè—è‰²ï¼Œä½¿ç”¨ marker 'arrow-return'
       *
       * ç¶²æ ¼æ¨¡å¼ï¼šä½¿ç”¨ grid_x/grid_y è¨ˆç®—æ ¼å¿ƒï¼ˆç›´æ¥è½‰æ›ç‚º SVG åº§æ¨™ï¼‰
       * åœ°åœ–æ¨¡å¼ï¼šä½¿ç”¨ grid_x/grid_y è¨ˆç®—æ ¼å¿ƒï¼Œä½†é€é GeoJSON coordinates çš„ä¸­å¿ƒé»ç¶“é projection è½‰æ›
       */
      const drawAngleArrows = () => {
        if (!g || !hexData.value) return;

        const isGridMode = displayMode.value === 'grid';

        // å…ˆæ¸…é™¤èˆŠçš„ç®­é ­
        g.selectAll('.angle-arrows').remove();

        const arrowsGroup = g
          .append('g')
          .attr('class', 'angle-arrows')
          .attr('pointer-events', 'none');

        // ç¢ºä¿ç®­é ­åœ–å±¤åœ¨æœ€ä¸Šå±¤
        if (arrowsGroup.raise) arrowsGroup.raise();

        const features = hexData.value.features || [];

        let validBorrow = 0;
        let validReturn = 0;
        let sampleCentroids = [];

        features.forEach((feature, idx) => {
          const borrowDeg = feature.properties?.['å€Ÿè»Šè§’åº¦å¹³å‡'];
          const returnDeg = feature.properties?.['é‚„è»Šè§’åº¦å¹³å‡'];
          const gridX = feature?.properties?.grid_x;
          const gridY = feature?.properties?.grid_y;

          if (!Number.isFinite(gridX) || !Number.isFinite(gridY)) return;

          let cx, cy;
          let arrowLengthForFeature = 12;

          if (isGridMode && gridLayoutConfig) {
            // ç¶²æ ¼æ¨¡å¼ï¼šä½¿ç”¨ grid_x/grid_y ç›´æ¥è¨ˆç®— SVG åº§æ¨™
            const { cellSize, offsetX, offsetY, minX, maxY } = gridLayoutConfig;
            cx = offsetX + (gridX - minX + 0.5) * cellSize;
            cy = offsetY + (maxY - gridY + 0.5) * cellSize;
            arrowLengthForFeature = Math.max(Math.min((cellSize || 0) * 0.42, 22), 5);
          } else if (projection && path) {
            // åœ°åœ–æ¨¡å¼ï¼šå¾ GeoJSON coordinates è¨ˆç®— polygon ä¸­å¿ƒï¼Œé€é projection è½‰æ›
            try {
              // ä½¿ç”¨ d3.geoCentroid å¾ GeoJSON coordinates è¨ˆç®—åœ°ç†ä¸­å¿ƒ
              const centroid = d3.geoCentroid(feature);
              const projected = projection(centroid);
              cx = projected?.[0];
              cy = projected?.[1];

              // å¦‚æœ geoCentroid å¤±æ•—ï¼Œå›é€€åˆ° path.centroid
              if (!Number.isFinite(cx) || !Number.isFinite(cy)) {
                [cx, cy] = path.centroid(feature);
              }

              // æ ¹æ“š polygon å¤§å°è¨ˆç®—ç®­é ­é•·åº¦
              if (Number.isFinite(cx) && Number.isFinite(cy)) {
                try {
                  const bounds = path.bounds(feature);
                  if (bounds && bounds.length === 2) {
                    const width = Math.abs(bounds[1][0] - bounds[0][0]);
                    const height = Math.abs(bounds[1][1] - bounds[0][1]);
                    const minSize = Math.min(width, height);
                    if (Number.isFinite(minSize) && minSize > 0) {
                      arrowLengthForFeature = Math.max(Math.min(minSize * 0.4, 26), 6);
                    } else {
                      arrowLengthForFeature = 14;
                    }
                  }
                } catch (err) {
                  arrowLengthForFeature = 14;
                }
              }
            } catch (e) {
              try {
                [cx, cy] = path.centroid(feature);
                arrowLengthForFeature = 14;
              } catch (err) {
                console.warn('Centroid calculation failed:', err);
                return;
              }
            }
          } else {
            return;
          }

          if (!Number.isFinite(cx) || !Number.isFinite(cy)) {
            return;
          }

          // è¨˜éŒ„å‰å¹¾å€‹ centroid ä½ç½®ç”¨æ–¼èª¿è©¦
          if (idx < 5 && (borrowDeg || returnDeg)) {
            sampleCentroids.push({ gridX, gridY, cx, cy, borrowDeg, returnDeg });
          }

          const drawOneArrow = (deg, color, markerId, offsetSign, pointToCenter = false) => {
            if (deg === null || deg === undefined || Number.isNaN(deg)) return;
            // ä»¥æŒ‡å—é‡è§’åº¦ç‚ºæº–ï¼šæ­£ä¸Šæ–¹=0Â°ï¼Œé †æ™‚é‡å¢åŠ 
            const rad = ((deg - 90) * Math.PI) / 180;
            const dx = Math.cos(rad) * arrowLengthForFeature;
            const dy = Math.sin(rad) * arrowLengthForFeature;

            const ox = 0;
            const oy = 0;

            const x1 = pointToCenter ? cx + ox - dx : cx + ox;
            const y1 = pointToCenter ? cy + oy - dy : cy + oy;
            const x2 = pointToCenter ? cx + ox : cx + ox + dx;
            const y2 = pointToCenter ? cy + oy : cy + oy + dy;

            arrowsGroup
              .append('line')
              .attr('x1', x1)
              .attr('y1', y1)
              .attr('x2', x2)
              .attr('y2', y2)
              .style('stroke', color)
              .attr('stroke-width', Math.max(arrowLengthForFeature * 0.12, 1.6))
              .attr('stroke-linecap', 'round')
              .attr('stroke-opacity', 1)
              .attr('class', 'angle-arrow');
          };

          // å€Ÿè»Šè§’åº¦ç®­é ­ï¼ˆç¶ ï¼‰å¾ä¸­å¿ƒæœå¤–
          const beforeB = arrowsGroup.selectAll('.angle-arrow').size();
          if (borrowDeg !== null && borrowDeg !== undefined && !Number.isNaN(borrowDeg)) {
            drawOneArrow(borrowDeg, '#4caf50', 'arrow-borrow', 1, false);
          }
          const afterB = arrowsGroup.selectAll('.angle-arrow').size();
          if (afterB > beforeB) validBorrow++;

          // é‚„è»Šè§’åº¦ç®­é ­ï¼ˆè—ï¼‰æœå‘ä¸­å¿ƒ
          const beforeR = arrowsGroup.selectAll('.angle-arrow').size();
          if (returnDeg !== null && returnDeg !== undefined && !Number.isNaN(returnDeg)) {
            drawOneArrow(returnDeg + 180, '#0068b7', 'arrow-return', -1, true);
          }
          const afterR = arrowsGroup.selectAll('.angle-arrow').size();
          if (afterR > beforeR) validReturn++;
        });

        let bbox = null;
        try {
          bbox = arrowsGroup.node()?.getBBox?.();
        } catch (e) {
          bbox = null;
        }

        // å°‡ç®­é ­åœ–å±¤å†æ¬¡ç½®é ‚
        if (arrowsGroup.raise) arrowsGroup.raise();

        console.log('[MapTab] è§’åº¦ç®­é ­ç¹ªè£½å®Œæˆ', {
          mode: isGridMode ? 'grid' : 'map',
          features: features.length,
          validBorrow,
          validReturn,
          totalArrows: arrowsGroup.selectAll('.angle-arrow').size(),
          bbox,
          sampleCentroids,
        });
      };

      // åœ–ä¾‹åŠŸèƒ½å·²ç§»é™¤ï¼ˆä¸å†é€²è¡Œåˆ†é¡è‘—è‰²ï¼‰

      /**
       * ğŸ—ï¸ å‰µå»ºåœ°åœ–å¯¦ä¾‹
       * åˆå§‹åŒ– D3.js åœ°åœ–ä¸¦è¨­å®šåŸºæœ¬é…ç½®
       */
      const createMap = (fitFeature = null) => {
        if (!mapContainer.value) return false;

        const rect = mapContainer.value.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          console.warn('[MapTab] å®¹å™¨å°ºå¯¸ç‚ºé›¶ï¼Œå»¶é²åˆå§‹åŒ–');
          return false;
        }

        try {
          const width = rect.width;
          const height = rect.height;

          // å°ç£ä¸­å¿ƒä½ç½®ï¼šç·¯åº¦ 23.5Â°, ç¶“åº¦ 121Â°

          // å‰µå»º SVG å…ƒç´ 
          svg = d3
            .select(mapContainer.value)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('background', '#ffffff'); // ç™½è‰²èƒŒæ™¯

          // å‰µå»ºæŠ•å½± - è‹¥æœ‰è³‡æ–™å‰‡è‡ªå‹•è²¼é½Šå€ç•Œï¼ˆå« 20px é‚Šè·ï¼‰
          projection = d3.geoMercator();
          if (fitFeature) {
            projection.fitExtent(
              [
                [20, 20],
                [width - 20, height - 20],
              ],
              fitFeature
            );
          } else {
            projection
              .center([121, 25.05])
              .scale(45000)
              .translate([width / 2, height / 2]);
          }

          // å‰µå»ºè·¯å¾‘ç”Ÿæˆå™¨
          path = d3.geoPath().projection(projection);

          // å‰µå»ºå®¹å™¨çµ„
          g = svg.append('g');

          // è¨­ç½®ç¸®æ”¾è¡Œç‚º
          zoom = d3
            .zoom()
            .scaleExtent([0.8, 12])
            .on('zoom', (event) => {
              g.attr('transform', event.transform);
            });

          svg.call(zoom);

          // é‡ç½®ç¸®æ”¾ç‹€æ…‹ï¼Œç¢ºä¿åˆ‡æ›æ¨¡å¼æ™‚ä¸æœƒå—åˆ°ä¹‹å‰æ¨¡å¼çš„å½±éŸ¿
          svg.call(zoom.transform, d3.zoomIdentity);

          // å‰µå»ºå·¥å…·æç¤ºå…ƒç´ 
          createTooltip();

          isMapReady.value = true;

          // å°‡åœ°åœ–å¯¦ä¾‹å‚³éçµ¦çˆ¶çµ„ä»¶
          emit('map-ready', { svg, projection, path });

          console.log('[MapTab] D3.js åœ°åœ–å‰µå»ºæˆåŠŸ');
          return true;
        } catch (error) {
          console.error('[MapTab] D3.js åœ°åœ–å‰µå»ºå¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸš€ åˆå§‹åŒ–åœ°åœ–
       * æ ¹æ“šåˆå§‹é¡¯ç¤ºæ¨¡å¼å‰µå»ºå°æ‡‰çš„è¦–åœ–
       */
      const initMap = async () => {
        let attempts = 0;
        const maxAttempts = 20;

        // æ ¹æ“šé¡¯ç¤ºæ¨¡å¼è¼‰å…¥ä¸åŒçš„æ•¸æ“š
        if (displayMode.value === 'map') {
          // åœ°åœ–æ¨¡å¼ï¼šéœ€è¦è¼‰å…¥ç¸£å¸‚ç•Œç·šå’Œå…­è§’å½¢ç¶²æ ¼æ•¸æ“š
          console.log('[MapTab] é–‹å§‹è¼‰å…¥åœ°åœ–æ¨¡å¼æ•¸æ“š...');
          const [countyLoaded, hexLoaded] = await Promise.all([loadCountyData(), loadHexData()]);

          if (!countyLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šæ•¸æ“š');
            return;
          }

          if (!hexLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“š');
            return;
          }

          console.log('[MapTab] æ‰€æœ‰æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œé–‹å§‹å‰µå»ºåœ°åœ–');

          const tryCreateMap = async () => {
            if (attempts >= maxAttempts) {
              console.error('[MapTab] åœ°åœ–åˆå§‹åŒ–å¤±æ•—ï¼Œå·²é”åˆ°æœ€å¤§å˜—è©¦æ¬¡æ•¸');
              return;
            }

            attempts++;
            console.log(`[MapTab] å˜—è©¦å‰µå»ºåœ°åœ– (${attempts}/${maxAttempts})`);

            if (createMap(countyData.value)) {
              console.log('[MapTab] åœ°åœ–å‰µå»ºæˆåŠŸï¼Œé–‹å§‹ç¹ªè£½åœ–å±¤');
              // å…ˆç¹ªè£½ç¸£å¸‚ç•Œç·šï¼ˆåº•å±¤ï¼‰
              drawCounties();
              // å†ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆä¸Šå±¤ï¼‰
              drawHexGrid();
            } else {
              console.log('[MapTab] åœ°åœ–å‰µå»ºå¤±æ•—ï¼Œ100ms å¾Œé‡è©¦');
              setTimeout(tryCreateMap, 100);
            }
          };

          tryCreateMap();
        } else {
          // Grid æ¨¡å¼ï¼šéœ€è¦è¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“šï¼Œéœ€è¦åœ°åœ–æŠ•å½±ä¾†ç¹ªè£½
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ç¶²æ ¼æ¨¡å¼æ•¸æ“š...');
          const hexLoaded = await loadHexData();

          if (!hexLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“š');
            return;
          }

          console.log('[MapTab] æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œé–‹å§‹å‰µå»ºç¶²æ ¼è¦–åœ–');

          const tryCreateGrid = async () => {
            if (attempts >= maxAttempts) {
              console.error('[MapTab] ç¶²æ ¼åˆå§‹åŒ–å¤±æ•—ï¼Œå·²é”åˆ°æœ€å¤§å˜—è©¦æ¬¡æ•¸');
              return;
            }

            attempts++;
            console.log(`[MapTab] å˜—è©¦å‰µå»ºç¶²æ ¼è¦–åœ– (${attempts}/${maxAttempts})`);

            if (createMap()) {
              console.log('[MapTab] ç¶²æ ¼è¦–åœ–å‰µå»ºæˆåŠŸï¼Œé–‹å§‹ç¹ªè£½å…­è§’å½¢ç¶²æ ¼');
              drawHexGridOnly();
            } else {
              console.log('[MapTab] ç¶²æ ¼è¦–åœ–å‰µå»ºå¤±æ•—ï¼Œ100ms å¾Œé‡è©¦');
              setTimeout(tryCreateGrid, 100);
            }
          };

          tryCreateGrid();
        }
      };

      // è™•ç†çª—å£å¤§å°èª¿æ•´ï¼ˆé‡æ–°ç¹ªè£½æ•´å€‹åœ°åœ–ï¼‰
      let resizeTimer = null;
      const handleResize = () => {
        // é˜²æŠ–è™•ç†ï¼Œé¿å…é »ç¹é‡ç¹ª
        if (resizeTimer) {
          clearTimeout(resizeTimer);
        }
        resizeTimer = setTimeout(() => {
          console.log('[MapTab] çª—å£å¤§å°èª¿æ•´ï¼Œé‡æ–°ç¹ªè£½åœ°åœ–');
          initMap();
        }, 300);
      };

      // ğŸ§¹ ç”Ÿå‘½é€±æœŸï¼šçµ„ä»¶æ›è¼‰
      onMounted(() => {
        nextTick(() => {
          initMap();
        });

        // ç›£è½çª—å£å¤§å°èª¿æ•´
        window.addEventListener('resize', handleResize);
      });

      // ğŸ§¹ ç”Ÿå‘½é€±æœŸï¼šçµ„ä»¶å¸è¼‰
      onUnmounted(() => {
        // æ¸…é™¤ resize timer
        if (resizeTimer) {
          clearTimeout(resizeTimer);
        }

        // ç§»é™¤ resize ç›£è½å™¨
        window.removeEventListener('resize', handleResize);

        if (svg) {
          svg.remove();
          svg = null;
        }

        // æ¸…ç†å·¥å…·æç¤º
        if (tooltip) {
          tooltip.remove();
          tooltip = null;
        }

        projection = null;
        path = null;
        zoom = null;
        g = null;
        isMapReady.value = false;
      });

      // ğŸ“¤ è¿”å›çµ„ä»¶å…¬é–‹çš„å±¬æ€§å’Œæ–¹æ³•
      return {
        mapContainer,
        mapContainerId,
        displayMode,
        toggleDisplayMode,
      };
    },
  };
</script>

<template>
  <!-- ğŸ—ºï¸ åœ°åœ–ä¸»å®¹å™¨ -->
  <div id="map-container" class="h-100 w-100 position-relative bg-transparent z-0">
    <!-- ğŸ—ºï¸ Leaflet åœ°åœ–å®¹å™¨ -->
    <div :id="mapContainerId" ref="mapContainer" class="h-100 w-100"></div>

    <!-- ğŸ›ï¸ å·¦å´ä¸­é–“æ§åˆ¶é¢æ¿ -->
    <div
      class="position-absolute"
      style="top: 50%; left: 0; transform: translateY(-50%); z-index: 1000; padding: 1rem"
    >
      <div class="bg-dark bg-opacity-75 rounded-3 p-3">
        <!-- ğŸ›ï¸ é¡¯ç¤ºæ¨¡å¼é¸æ“‡å€åŸŸ -->
        <div class="">
          <div class="d-flex flex-column gap-1">
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'map' ? 'active' : '']"
              @click="toggleDisplayMode('map')"
            >
              åœ°åœ–æ¨¡å¼
            </button>
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'grid' ? 'active' : '']"
              @click="toggleDisplayMode('grid')"
            >
              ç¶²æ ¼æ¨¡å¼
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
  @import '../assets/css/common.css';

  #map-container {
    overflow: hidden;
  }

  :deep(.leaflet-container) {
    background: #ffffff; /* ç™½è‰²èƒŒæ™¯ */
  }

  :deep(.leaflet-popup-content-wrapper) {
    background: rgba(0, 43, 127, 0.95); /* è«¾é­¯æ·±è—è‰²åŠé€æ˜ */
    color: #ffc61e; /* é‡‘é»ƒè‰²æ–‡å­— */
    border: 2px solid #ffc61e; /* é‡‘é»ƒè‰²é‚Šæ¡† */
  }

  :deep(.leaflet-popup-tip) {
    background: rgba(0, 43, 127, 0.95); /* è«¾é­¯æ·±è—è‰²åŠé€æ˜ */
  }

  :deep(.leaflet-tooltip) {
    background-color: rgba(0, 43, 127, 0.95) !important; /* è«¾é­¯æ·±è—è‰² */
    color: #ffc61e !important; /* é‡‘é»ƒè‰²æ–‡å­— */
    border: 1px solid #ffc61e !important; /* é‡‘é»ƒè‰²é‚Šæ¡† */
    font-size: 14px;
    padding: 8px 12px;
    border-radius: 4px;
    line-height: 1.4;
  }

  :deep(.map-tooltip) {
    background-color: #333; /* æ·±ç°è‰²èƒŒæ™¯ */
    color: #fff; /* ç™½è‰²æ–‡å­— */
    border: none; /* ç„¡é‚Šæ¡† */
  }
</style>
